# 進捗状況
## 2017/05/2X
Elixir SchoolのページをTwitterか何かで知る。

前々から名前は聞いたことがあったので環境を導入。

```
brew install elixir
```

を打ち込むだけ。Macなので導入が楽でよかった。


[公式ページのインストール手順](https://elixir-lang.org/install.html)



## 2017/05/3X
1.基本、2.コレクションを読み終わって実行してみる。


### 1.基本を読んで
`iex` コマンドでインタラクティブに実行できる。


- 基本データ型は他言語とそんなに変わらない。 
- `|>` 記号になれない。
- `==` と `===` があるタイプの言語
- 文字列の連結が `<>` なのでこの点は少し変わってるかも。

```
iex> name = "Yumechi"
iex> "ぼくは" <> name
ぼくはYumechi
```

- Rubyっぽく式展開も可能


ここまでだと他の言語とそんなに大差がない印象。

### 2.コレクションを読んで
- List, Tuples, Keyword lists, Maps がある
- 何でも入る系（型の意識いらず）
- `++` で連結、 `--` で差が取れる。
- 差を取るときは最初のものから削除される。厳密な比較（ notesに書いてある内容がこれ ）

```
iex(1)> [1, 2, 3, 4] -- [1, 2, 3, 4]
[]
iex(2)> [1, 2, 3, 4, 1] -- [1, 2, 3, 4]
[1]
iex(3)> [1, 2, 3, 4, 1] -- [1, 1, 3, 4]
[2]
iex(4)> [1, 2, 3, 4, 1] -- [1.0, 2, 3, 4]
[1, 1]
```

- File.readの例があるけど、こんなに簡単にファイル読み込みできるのか…
- keyword listの使い所がいまいちわからない（関数にオプションを渡す際に使えると書いてあるが… ）
- Mapは `%{key => value, key2 => value2}` のように定義する。
- Keyword listを実際に使ってみないとわからないなあ。。。他の言語でもあまり使いこなせていないから、実例が思いつかないのかも。


## 2017/06/01
3.Enumを読み終わって、4.パターンマッチングを読んでる。

### 3.Enumを読んで

日本語版の方は最新版から若干古く、現在のメジャーバージョンと差異がありますよ、という記載があるため、ここから英語版と日本語版を交互に行ったり来たり…

- `all?` は全てが該当するかどうか、 `any?` はいずれかが該当するかどうか
- `Enum.any?(["矢澤にこ", "星空凛", "小泉花陽"], fn(s) -> s == "矢澤にこ" end)` のように使う（この場合は当然true）
    - 若干、関数？ ラムダ？の書き方に癖がある。endつけないといけないのね。
- `chunk`, `chunk_by` は要素を切り出すために使う。`chunk` は単位を、`chunk_by` は条件を第2引数に渡す
    - 私には使いどころがわからなかった。どう使えばいいんだろう。
- `map_every` は指定したステップの箇所だけ処理を行う（**これが日本語版にないやつ**）

```
iex(3)> Enum.map_every(["やさい", "さかな", "くだもの", "おやつ", "にく", "おこめ", "ぱすた"], 2, fn x -> x <> "にこー" end)
["やさいにこー", "さかな", "くだものにこー", "おやつ", "にくにこー", "おこめ", "ぱすたにこー"]
```

- `each` , `map` はそれぞれの要素に処理をするもの。 `each` は新しい値に書き換える必要がないとき、 `map` は新しい値に置き換えたコレクションが必要なときに使う、という使い分けが存在する。
- `min`, `max` は最大値、最小値を求める。
    - 一応、第2引数が設定できて、第1引数のコレクションが空のときにデフォルトの値を入れるようになっているけど、使うケースが想定できない。
    - 非同期処理で何も値が入っていないときとか？
- `reduce` はそれぞれの要素を合算したものを返す（リストの総和とか求めるのに使える、概念的に理解しているので読み飛ばす）
- `sort` は並び替え。リストの要素は何でも入るが、並び替え順は要素の型（数値、文字列等）に左右されるため注意。これはElixirに特有の事象らしい。（Erlangも？）
- `uniq` は重複した値を消す。他言語のsetに入れたときの操作みたい。

結構関数型っぽい処理もできるようなので、最近の言語っぽさを感じた。しかしどう使えばいいのか今のところ思いつかないものもあるので、いい例を思いついたら練習したいかも。


## 2017/06/06
4. pattern matchingを読み終わった。

### 4.pattern matchingを読んで
- マッチ演算子、ピン演算子がある
- elixir では `=` はマッチ演算子である
    - `x = 1` は x に1を代入する 
    - `1 = x` は x が1であるかどうかを検証する
        - x が 1以外ならMatchErrorが発生する
- ピン演算子は再代入を防ぐために使用する
    - `x = 1` としたあと、 `^x = 2` とすると、MatchError が発生する
    - `{x, ^x} = {2, 1}` のように代入しなければいけない
- **これらの機能がなぜ存在するのかというとErlangは元々再代入が禁止されている(!)言語だからである。**
    - 参考資料：[翻訳] ElixirとErlangの変数を比較する http://qiita.com/HirofumiTamori/items/6691d1dd426a44ec3d2a
    - なぜこのような機能が存在するのかというと、関数型のエッセンスもふんだんに取り入れた言語なんだなあと、いうことがわかる。。。
    - elixir schoolではそのあたりの背景の説明が少なかったので、唐突に出てきて非常に疑問だった。やっぱり Erlang 自体も少し理解してないと厳しいのかな。


引き続き読んでいこう…。


### 2017/06/08
昨日は体調が悪かったので連続コミットが途切れた…。

5.Control Structures（制御構文）を読んだ。

#### 5.Control Structuresを読んで
- 制御構文には `if/unless`, `case`, `cond`, `with` がある
- `if` 文でfalse判定になるのは、nilである場合とboolean値がfalseである場合である。
- C言語等のように0がfalse判定されることはない

```
iex(1)> if 1 do
...(1)>     IO.puts("1はtrue")
...(1)> end
1はtrue
:ok
iex(2)> if 0 do
...(2)>     IO.puts("0もtrue")
...(2)> end
0もtrue
:ok
```

- else文も書ける
```
iex(3)> if is_integer("矢澤にこ") do
...(3)>    IO.puts("数字です")
...(3)> else
...(3)>    IO.puts("数字じゃないです")
...(3)> end
数字じゃないです
```

- unlessはif notみたいな感じ。

- case文は複数のマッチングに使える。他言語のswitch文みたいなもの。
- どの条件にも入らなかった場合は `_` を使って指定する
- もしどの条件にも当てはまらないものを処理していないと、`CaseClauseError`が発生する

```
iex(4)> case {:ok, "Hello World", :key, "こんにちは"} do
...(4)>    {:ok, result} -> result
...(4)>    {:error} -> "Uh oh!"
...(4)> end
** (CaseClauseError) no case clause matching: {:ok, "Hello World", :key, "こんにちは"}
    
iex(4)> case {:ok, "Hello World", :key, "こんにちは"} do
...(4)>    {:error} -> "Uh oh!"                         
...(4)>    {:ok, result} -> result                      
...(4)>    _ -> "うーん"
...(4)> end
"うーん"
iex(5)> case {:ok, "Hello World", :key, "こんにちは"} do
...(5)>    {:ok, result} -> result                      
...(5)>    {:error} -> "Uh oh!"                         
...(5)>    {:ok, result, :key, value} -> result <> " " <> value
...(5)> end
"Hello World こんにちは"
```

condとwithはまだよくわからない部分もあるので、続きはまた明日。
withはswiftのif-letっぽいなあという解釈なんだけど、どうなんだろう。。。
